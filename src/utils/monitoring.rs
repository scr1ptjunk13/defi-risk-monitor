use std::time::{Duration, Instant};
use std::sync::Arc;
use prometheus::{
    Counter, Gauge, Registry, Encoder, TextEncoder,
    HistogramOpts, Opts, CounterVec, GaugeVec, HistogramVec,
};
use tracing::info;
use crate::error::AppError;

use std::collections::HashMap;

/// Production-grade metrics collector for DeFi risk monitoring
pub struct MetricsCollector {
    registry: Registry,
    
    // Business Metrics
    pub positions_monitored: Gauge,
    pub risk_calculations_total: Counter,
    pub alerts_generated: CounterVec,
    pub pool_state_fetches: CounterVec,
    
    // Performance Metrics
    pub request_duration: HistogramVec,
    pub blockchain_rpc_duration: HistogramVec,
    pub database_query_duration: HistogramVec,
    
    // System Health Metrics
    pub circuit_breaker_state: GaugeVec,
    pub retry_attempts: CounterVec,
    pub error_count: CounterVec,
    
    // Financial Metrics
    pub total_value_monitored: Gauge,
    pub high_risk_positions: Gauge,
    pub liquidation_alerts: Counter,
}

impl MetricsCollector {
    pub fn new() -> Result<Self, AppError> {
        let registry = Registry::new();
        
        // Business Metrics
        let positions_monitored = Gauge::with_opts(
            Opts::new("defi_positions_monitored_total", "Total number of positions being monitored")
        ).map_err(|e| AppError::InternalError(format!("Failed to create positions metric: {}", e)))?;
        
        let risk_calculations_total = Counter::with_opts(
            Opts::new("defi_risk_calculations_total", "Total number of risk calculations performed")
        ).map_err(|e| AppError::InternalError(format!("Failed to create risk calculations metric: {}", e)))?;
        
        let alerts_generated = CounterVec::new(
            Opts::new("defi_alerts_generated_total", "Total alerts generated by severity"),
            &["severity", "type"]
        ).map_err(|e| AppError::InternalError(format!("Failed to create alerts metric: {}", e)))?;
        
        let pool_state_fetches = CounterVec::new(
            Opts::new("defi_pool_state_fetches_total", "Pool state fetch attempts by chain and status"),
            &["chain_id", "status"]
        ).map_err(|e| AppError::InternalError(format!("Failed to create pool state metric: {}", e)))?;
        
        // Performance Metrics
        let request_duration = HistogramVec::new(
            HistogramOpts::new("defi_request_duration_seconds", "Request duration in seconds")
                .buckets(vec![0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0, 5.0, 10.0]),
            &["endpoint", "method"]
        ).map_err(|e| AppError::InternalError(format!("Failed to create request duration metric: {}", e)))?;
        
        let blockchain_rpc_duration = HistogramVec::new(
            HistogramOpts::new("defi_blockchain_rpc_duration_seconds", "Blockchain RPC call duration")
                .buckets(vec![0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 30.0]),
            &["chain_id", "method"]
        ).map_err(|e| AppError::InternalError(format!("Failed to create RPC duration metric: {}", e)))?;
        
        let database_query_duration = HistogramVec::new(
            HistogramOpts::new("defi_database_query_duration_seconds", "Database query duration")
                .buckets(vec![0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0]),
            &["query_type"]
        ).map_err(|e| AppError::InternalError(format!("Failed to create DB duration metric: {}", e)))?;
        
        // System Health Metrics
        let circuit_breaker_state = GaugeVec::new(
            Opts::new("defi_circuit_breaker_state", "Circuit breaker state (0=closed, 1=open, 2=half-open)"),
            &["service"]
        ).map_err(|e| AppError::InternalError(format!("Failed to create circuit breaker metric: {}", e)))?;
        
        let retry_attempts = CounterVec::new(
            Opts::new("defi_retry_attempts_total", "Total retry attempts by service and outcome"),
            &["service", "outcome"]
        ).map_err(|e| AppError::InternalError(format!("Failed to create retry metric: {}", e)))?;
        
        let error_count = CounterVec::new(
            Opts::new("defi_errors_total", "Total errors by type and service"),
            &["error_type", "service"]
        ).map_err(|e| AppError::InternalError(format!("Failed to create error metric: {}", e)))?;
        
        // Financial Metrics
        let total_value_monitored = Gauge::with_opts(
            Opts::new("defi_total_value_monitored_usd", "Total USD value of positions being monitored")
        ).map_err(|e| AppError::InternalError(format!("Failed to create total value metric: {}", e)))?;
        
        let high_risk_positions = Gauge::with_opts(
            Opts::new("defi_high_risk_positions_total", "Number of positions with high risk scores")
        ).map_err(|e| AppError::InternalError(format!("Failed to create high risk metric: {}", e)))?;
        
        let liquidation_alerts = Counter::with_opts(
            Opts::new("defi_liquidation_alerts_total", "Total liquidation risk alerts generated")
        ).map_err(|e| AppError::InternalError(format!("Failed to create liquidation alerts metric: {}", e)))?;
        
        // Register all metrics
        registry.register(Box::new(positions_monitored.clone()))?;
        registry.register(Box::new(risk_calculations_total.clone()))?;
        registry.register(Box::new(alerts_generated.clone()))?;
        registry.register(Box::new(pool_state_fetches.clone()))?;
        registry.register(Box::new(request_duration.clone()))?;
        registry.register(Box::new(blockchain_rpc_duration.clone()))?;
        registry.register(Box::new(database_query_duration.clone()))?;
        registry.register(Box::new(circuit_breaker_state.clone()))?;
        registry.register(Box::new(retry_attempts.clone()))?;
        registry.register(Box::new(error_count.clone()))?;
        registry.register(Box::new(total_value_monitored.clone()))?;
        registry.register(Box::new(high_risk_positions.clone()))?;
        registry.register(Box::new(liquidation_alerts.clone()))?;
        
        info!("Metrics collector initialized with {} metrics", 13);
        
        Ok(Self {
            registry,
            positions_monitored,
            risk_calculations_total,
            alerts_generated,
            pool_state_fetches,
            request_duration,
            blockchain_rpc_duration,
            database_query_duration,
            circuit_breaker_state,
            retry_attempts,
            error_count,
            total_value_monitored,
            high_risk_positions,
            liquidation_alerts,
        })
    }
    
    /// Export metrics in Prometheus format
    pub fn export_metrics(&self) -> Result<String, AppError> {
        let encoder = TextEncoder::new();
        let metric_families = self.registry.gather();
        
        let mut buffer = Vec::new();
        encoder.encode(&metric_families, &mut buffer)
            .map_err(|e| AppError::InternalError(format!("Failed to encode metrics: {}", e)))?;
        
        String::from_utf8(buffer)
            .map_err(|e| AppError::InternalError(format!("Failed to convert metrics to string: {}", e)))
    }
    
    /// Record a successful operation
    pub fn record_success(&self, operation: &str, duration: Duration) {
        self.request_duration
            .with_label_values(&[operation, "success"])
            .observe(duration.as_secs_f64());
    }
    
    /// Record a failed operation
    pub fn record_error(&self, operation: &str, error_type: &str, duration: Duration) {
        self.request_duration
            .with_label_values(&[operation, "error"])
            .observe(duration.as_secs_f64());
        
        self.error_count
            .with_label_values(&[error_type, operation])
            .inc();
    }
    
    /// Record blockchain RPC call
    pub fn record_blockchain_rpc(&self, chain_id: i32, method: &str, duration: Duration, success: bool) {
        self.blockchain_rpc_duration
            .with_label_values(&[&chain_id.to_string(), method])
            .observe(duration.as_secs_f64());
        
        let status = if success { "success" } else { "error" };
        self.pool_state_fetches
            .with_label_values(&[&chain_id.to_string(), status])
            .inc();
    }
    
    /// Update circuit breaker state
    pub fn update_circuit_breaker_state(&self, service: &str, state: u8) {
        self.circuit_breaker_state
            .with_label_values(&[service])
            .set(state as f64);
    }
    
    /// Record retry attempt
    pub fn record_retry(&self, service: &str, success: bool) {
        let outcome = if success { "success" } else { "failure" };
        self.retry_attempts
            .with_label_values(&[service, outcome])
            .inc();
    }
}

/// Global metrics instance
static METRICS: tokio::sync::OnceCell<Arc<MetricsCollector>> = tokio::sync::OnceCell::const_new();

/// Initialize global metrics collector
pub async fn init_metrics() -> Result<(), AppError> {
    let metrics = Arc::new(MetricsCollector::new()?);
    METRICS.set(metrics)
        .map_err(|_| AppError::InternalError("Metrics already initialized".to_string()))?;
    
    info!("Global metrics collector initialized");
    Ok(())
}

/// Get global metrics instance
pub async fn get_metrics() -> Result<Arc<MetricsCollector>, AppError> {
    METRICS.get()
        .ok_or_else(|| AppError::InternalError("Metrics not initialized".to_string()))
        .map(|m| m.clone())
}

/// Timer for measuring operation duration
pub struct Timer {
    start: Instant,
    operation: String,
}

impl Timer {
    pub fn new(operation: &str) -> Self {
        Self {
            start: Instant::now(),
            operation: operation.to_string(),
        }
    }
    
    pub async fn finish_success(self) {
        if let Ok(metrics) = get_metrics().await {
            metrics.record_success(&self.operation, self.start.elapsed());
        }
    }
    
    pub async fn finish_error(self, error_type: &str) {
        if let Ok(metrics) = get_metrics().await {
            metrics.record_error(&self.operation, error_type, self.start.elapsed());
        }
    }
}

/// Health check status
#[derive(Debug, Clone, serde::Serialize)]
pub struct HealthStatus {
    pub healthy: bool,
    pub checks: HashMap<String, bool>,
    pub uptime: Duration,
    pub version: String,
}

/// Health checker for production monitoring
pub struct HealthChecker {
    start_time: Instant,
    version: String,
}

impl HealthChecker {
    pub fn new(version: &str) -> Self {
        Self {
            start_time: Instant::now(),
            version: version.to_string(),
        }
    }
    
    /// Perform comprehensive health check
    pub async fn check_health(&self) -> HealthStatus {
        let mut checks = HashMap::new();
        
        // Check metrics availability
        checks.insert("metrics".to_string(), get_metrics().await.is_ok());
        
        // Check database connectivity (would be implemented with actual DB pool)
        checks.insert("database".to_string(), true); // Placeholder
        
        // Check blockchain RPC connectivity (would ping actual RPCs)
        checks.insert("ethereum_rpc".to_string(), true); // Placeholder
        checks.insert("polygon_rpc".to_string(), true); // Placeholder
        checks.insert("arbitrum_rpc".to_string(), true); // Placeholder
        
        let healthy = checks.values().all(|&v| v);
        
        HealthStatus {
            healthy,
            checks,
            uptime: self.start_time.elapsed(),
            version: self.version.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;
    
    #[tokio::test]
    async fn test_metrics_collector_creation() {
        let metrics = MetricsCollector::new();
        assert!(metrics.is_ok());
    }
    
    #[tokio::test]
    async fn test_metrics_export() {
        let metrics = MetricsCollector::new().unwrap();
        let exported = metrics.export_metrics();
        assert!(exported.is_ok());
        assert!(exported.unwrap().contains("defi_"));
    }
    
    #[tokio::test]
    async fn test_timer() {
        let timer = Timer::new("test_operation");
        tokio::time::sleep(Duration::from_millis(10)).await;
        timer.finish_success().await; // Should not panic
    }
    
    #[tokio::test]
    async fn test_health_checker() {
        let health_checker = HealthChecker::new("1.0.0");
        tokio::time::sleep(std::time::Duration::from_millis(1)).await;
        let status = health_checker.check_health().await;
        assert_eq!(status.version, "1.0.0");
        assert!(status.uptime.as_nanos() > 0);
    }
}
